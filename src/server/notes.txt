1. udp functions
2. udp threads
3. create packet, use packet, verify it is getting updated, free packet.
4. create testmode by default is false. It toggles between the old mode and the new http inside the tcp threads.
Or maybe I can change the thread creation and add a thread specific for http. That would let me handle it better (?).
In theory it should be the same but I send a message directly and receive directly without getting the length first.
Get request -> understand request, find resource, check resource type, create headers
Send Response -> we send headers first and then we do a second send where we do a sendfile.
It is really important to handle the file with locking mechanism.

Heartbeat example

Servidor

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/select.h>

#define PORT 9999
#define BUF_SIZE 1024

int main() {
    int sockfd, heartbeat_sockfd, max_sd, activity;
    struct sockaddr_in server_addr, client_addr, heartbeat_addr;
    fd_set readfds;
    char buffer[BUF_SIZE];
    socklen_t addr_len = sizeof(client_addr);

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Error al crear socket TCP");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(sockfd, (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Error al hacer bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    if (listen(sockfd, 3) < 0) {
        perror("Error al escuchar");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    if ((heartbeat_sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("Error al crear socket UDP");
        exit(EXIT_FAILURE);
    }

    memset(&heartbeat_addr, 0, sizeof(heartbeat_addr));
    heartbeat_addr.sin_family = AF_INET;
    heartbeat_addr.sin_addr.s_addr = INADDR_ANY;
    heartbeat_addr.sin_port = htons(PORT + 1);

    if (bind(heartbeat_sockfd, (const struct sockaddr *)&heartbeat_addr, sizeof(heartbeat_addr)) < 0) {
        perror("Error al hacer bind para heartbeat");
        close(heartbeat_sockfd);
        exit(EXIT_FAILURE);
    }

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);
        FD_SET(heartbeat_sockfd, &readfds);
        max_sd = sockfd > heartbeat_sockfd ? sockfd : heartbeat_sockfd;

        activity = select(max_sd + 1, &readfds, NULL, NULL, NULL);

        if (activity < 0 && errno != EINTR) {
            perror("Error en select");
        }

        if (FD_ISSET(sockfd, &readfds)) {
            int new_socket = accept(sockfd, (struct sockaddr *)&client_addr, &addr_len);
            if (new_socket < 0) {
                perror("Error en accept");
                exit(EXIT_FAILURE);
            }

            int n = read(new_socket, buffer, BUF_SIZE);
            buffer[n] = '\0';
            printf("Mensaje TCP recibido: %s\n", buffer);
            write(new_socket, "ack", strlen("ack"));
            close(new_socket);
        }

        if (FD_ISSET(heartbeat_sockfd, &readfds)) {
            int n = recvfrom(heartbeat_sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *)&client_addr, &addr_len);
            buffer[n] = '\0';
            printf("Mensaje UDP de heartbeat recibido: %s\n", buffer);
            sendto(heartbeat_sockfd, "ack", strlen("ack"), 0, (struct sockaddr *)&client_addr, addr_len);
        }
    }

    close(sockfd);
    close(heartbeat_sockfd);
    return 0;
}

cliente

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 9999
#define BUF_SIZE 1024
#define HEARTBEAT_INTERVAL 5

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[BUF_SIZE];
    socklen_t addr_len = sizeof(server_addr);

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("Error al crear socket UDP");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT + 1);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    while (1) {
        sendto(sockfd, "heartbeat", strlen("heartbeat"), 0, (const struct sockaddr *)&server_addr, addr_len);
        printf("Mensaje de heartbeat enviado\n");

        int n = recvfrom(sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *)&server_addr, &addr_len);
        buffer[n] = '\0';
        printf("Respuesta recibida: %s\n", buffer);

        sleep(HEARTBEAT_INTERVAL);
    }

    close(sockfd);
    return 0;
}